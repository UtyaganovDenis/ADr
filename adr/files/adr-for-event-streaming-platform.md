# ADR for event streaming platform   
**Дата**: 2024-11-12
**Решение**: Использовать Apache Kafka в качестве брокера сообщений   
 --- 
### Контекст   
Проект предполагает работу с системой обмена сообщениями, которая будет использоваться для интеграции между микросервисами, обработки событий и реализации асинхронной архитектуры. Основные требования к брокеру сообщений:   
1. **Высокая производительность**: поддержка большого количества сообщений с минимальной задержкой.   
2. **Надёжность и отказоустойчивость**: обеспечение доставки сообщений даже в условиях сбоя.   
3. **Масштабируемость**: возможность обработки увеличивающегося объёма данных без потери производительности.   
4. **Гарантии доставки**: поддержка одной из моделей доставки сообщений (например, at-least-once, exactly-once).   
5. **Активное сообщество и документация**: наличие поддерживаемого экосистемой продукта с богатым набором инструментов.   
6. **Гибкость интеграции**: совместимость с современными языками программирования, фреймворками и инструментами.   
   
Рассматриваемые варианты: **Apache Kafka**, **RabbitMQ**, **Redis Streams**.   
 --- 
### Анализ кондидатов   
### 1. Apache Kafka   
### Высокая производительность   
Kafka разработан для обработки огромного количества сообщений с минимальной задержкой. Благодаря архитектуре на основе логов и дисковой записи, Kafka достигает высокой пропускной способности и низкой задержки.   
### Надёжность и отказоустойчивость   
Kafka обеспечивает надёжность за счёт репликации данных между брокерами. В случае сбоя одного узла, данные остаются доступными на других репликах.   
### Масштабируемость   
Kafka легко масштабируется горизонтально путём добавления новых брокеров. Он поддерживает шардирование данных через разделы (partitions), что позволяет распределять нагрузку между узлами.   
### Гарантии доставки   
Kafka поддерживает несколько моделей доставки сообщений:   
- **At-least-once**: Сообщения доставляются как минимум один раз.   
- **Exactly-once**: Доставка сообщений ровно один раз при использовании транзакций.   
   
### Активное сообщество и документация   
Kafka имеет активное сообщество и богатую экосистему инструментов, таких как Kafka Streams, Confluent Platform и Kafka Connect. Документация обширна и регулярно обновляется.   
### Гибкость интеграции   
Kafka поддерживает интеграцию с современными языками программирования (Java, Python, Go и др.) и фреймворками. Он совместим с популярными инструментами для обработки данных и микросервисной архитектуры.   
### 2. RabbitMQ   
### Высокая производительность   
RabbitMQ обеспечивает хорошую производительность для среднего объёма сообщений, но при высоких нагрузках может уступать Kafka из-за своей архитектуры и необходимости подтверждения сообщений.   
### Надёжность и отказоустойчивость   
RabbitMQ поддерживает надёжность через механизмы подтверждения доставки сообщений и репликацию. Однако отказоустойчивость требует дополнительных настроек и может быть сложной в управлении.   
### Масштабируемость   
RabbitMQ масштабируется как вертикально, так и горизонтально, но горизонтальное масштабирование требует использования дополнительных плагинов, таких как Federation или Sharding.   
### Гарантии доставки   
RabbitMQ поддерживает модели **at-least-once** и **at-most-once**, но **exactly-once** недоступен из коробки.   
### Активное сообщество и документация   
RabbitMQ имеет активное сообщество и хорошую документацию. Однако экосистема инструментов менее развита по сравнению с Kafka.   
### Гибкость интеграции   
RabbitMQ поддерживает большинство современных языков программирования, что делает его гибким для интеграции.   
### 3. Redis Streams   
### Высокая производительность   
Redis Streams обеспечивает высокую производительность благодаря хранению данных в памяти. Однако при больших объёмах сообщений это может привести к увеличению потребления оперативной памяти.   
### Надёжность и отказоустойчивость   
Redis поддерживает репликацию и резервное копирование, но надёжность зависит от конфигурации. В случае сбоя узла могут возникнуть потери данных.   
### Масштабируемость   
Redis Streams масштабируется через Redis Cluster, но настройка и управление кластером могут быть сложными.   
### Гарантии доставки   
Redis Streams поддерживает **at-least-once** модель доставки сообщений. Гарантия **exactly-once** отсутствует.   
### Активное сообщество и документация   
Redis имеет большое и активное сообщество, а также отличную документацию. Однако Redis Streams как функциональность относительно новая и имеет меньше готовых решений.   
### Гибкость интеграции   
Redis Streams поддерживает интеграцию с современными языками программирования и инструментами, но его экосистема менее развита по сравнению с Kafka.   
 --- 
### Решение   
После анализа было принято решение использовать **Apache Kafka** в качестве основного брокера сообщений.   
 --- 
### Обоснование выбора   
1. **Производительность**:
Kafka превосходит конкурентов в обработке большого объёма сообщений благодаря своей архитектуре, основанной на записи в логи.   
2. **Масштабируемость**:
Kafka поддерживает горизонтальное масштабирование через разделы (partitions), что делает её идеальной для проектов с высоким ростом нагрузки.   
3. **Надёжность**:
Kafka гарантирует доставку сообщений, сохраняя данные в реплицированных логах. Это обеспечивает их доступность даже при сбое отдельных узлов.   
4. **Работа с потоками данных**:
Kafka не только брокер сообщений, но и мощный инструмент для обработки потоков данных в реальном времени (Kafka Streams).   
5. **Гибкость интеграции**:
Kafka поддерживает интеграцию с различными языками программирования и инструментами через клиентские библиотеки и коннекторы.   
6. **Активное сообщество и экосистема**:
Постоянное развитие Kafka и наличие расширений (например, Confluent Platform) делает её универсальным инструментом для различных сценариев.   
 --- 
   
### Последствия   
1. **Положительные**:   
    - Возможность эффективно обрабатывать большие объёмы данных с минимальной задержкой.   
    - Надёжность системы благодаря встроенной отказоустойчивости.   
    - Удобство интеграции с другими сервисами и инструментами.   
    - Поддержка сложных сценариев обработки событий, таких как event sourcing или CQRS.   
2. **Негативные**:   
    - Требуется время на настройку и обучение команды работе с Kafka.   
    - Увеличение требований к инфраструктуре для обеспечения стабильной работы.   
    - Необходимость в разработке BusService, который будет являться прослойкой предоставляющей интерфейс для работы с брокером.   
 --- 
